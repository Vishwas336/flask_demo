<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flask Test</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>
  <body>
    <script type="text/javascript">
      var dataFromPython = {{ data|tojson|safe }};
      console.log(dataFromPython);


      let canvasSelect = d3.select("body")
        .append("canvas")
        .attr("width", 960)
        .attr("height", 500);

        let context = canvasSelect.node().getContext("2d");

        let width = canvasSelect.property("width");
        let height = canvasSelect.property("height");

        const r = 1.5; // Radius of circle

        d3.select(context.canvas)
          .call(d3.zoom()
            .scaleExtent([1, 20])
            .on("zoom", ({ transform }) => zoomed(transform)));

            // function performSearch(x0, x1, y0, y1) {
            // // Perform an AJAX request to app.py with the x0, x1, y0, and y1 values
            // // Update the URL to match your Flask route
            // fetch("/search", {
            //     method: "POST",
            //     body: JSON.stringify({ x0, x1, y0, y1 }),
            //     headers: {
            //         "Content-Type": "application/json",
            //     },
            // })
            //     .then((response) => response.json())
            //     .then((data) => {
            //         // Handle the response data (e.g., update the displayed data)
            //         console.log(data);
            //     })
            //     .catch((error) => {
            //         console.error("Error:", error);
            //     });}

          let searchData=[]; // Variable to store the data

          function performSearch(x0, x1, y0, y1) {
            return new Promise((resolve, reject) => {
                fetch("/search", {
                    method: "POST",
                    body: JSON.stringify({ x0, x1, y0, y1 }),
                    headers: {
                        "Content-Type": "application/json",
                    },
                })
                .then((response) => response.json())
                .then((data) => {
                    resolve(data); // Resolve the Promise with the received data
                })
                .catch((error) => {
                    reject(error); // Reject the Promise with the error
                });
            });
        }
            
            function zoomed(transform) {
              // console.log(transform)
              context.save();
              context.clearRect(0, 0, width, height);
              context.translate(transform.x, transform.y);
              context.scale(transform.k, transform.k);
              context.beginPath();

              let origin = transform.invert([0, 0]);
              let endingPoint = transform.invert([width, height]);
              console.log(origin,endingPoint)
            //
              let x0 = origin[0];
              let y0 = origin[1];

              let x1 = endingPoint[0];
              let y1 = endingPoint[1];

              // reduce size of rectangle by 0.9
              // let dx = (x1 - x0) * 0.1;
              // let dy = (y1 - y0) * 0.1;

              // x0 += dx;
              // x1 -= dx;
              // y0 += dy;
              // y1 -= dy;
              
              performSearch(x0, x1, y0, y1)
                .then((data) => {
                    // Handle the data, e.g., store it in a variable
                    //sending data to a global variable
                    for (const [x,y] of data){
                      searchData.push([x,y])
                    }
                    searchData = data;
                    // console.log(searchData);

                    // You can use 'receivedData' anywhere in your script
                })
                .catch((error) => {
                    console.error("Error:", error);
                });
              
              // // shuffle the sample points according to pre calculated white noise
              // samplePoints.sort((a, b) => a[2] - b[2]);
              // // limit the number of sample points to 1000

               if(searchData.length>1000){
                searchData.length = 1000;
               }
              
              for (const [x, y] of searchData) {
                context.moveTo(x + r, y);
                context.arc(x, y, r, 0, 2 * Math.PI);
              }


              context.fill();
              context.save();
              context.beginPath();
              context.moveTo(x0, y0);
              context.lineTo(x0, y1);
              context.lineTo(x1, y1);
              context.lineTo(x1, y0);
              context.closePath();
              // red stroke width 3
              context.strokeStyle = "red";
              context.lineWidth = 3;
              context.stroke();
              context.restore();
              context.restore();
            }

            zoomed(d3.zoomIdentity);
</script>
</body></html>


